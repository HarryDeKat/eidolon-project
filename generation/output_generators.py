# This module handles the creation of all final output files (RSS, Markdown).

import os
import re
import datetime
import urllib.parse
import markdown
import xml.etree.ElementTree as ET
from xml.dom import minidom
from config import RSS_FILE, STORIES_DIR

def clean_invalid_xml_chars(text):
    """Removes any characters that are not valid in XML 1.0 documents."""
    invalid_xml_chars_re = re.compile(
        u'[^\u0009\u000a\u000d\u0020-\uD7FF\uE000-\uFFFD\U00010000-\U0010FFFF]'
    )
    return invalid_xml_chars_re.sub('', text)

def strip_markdown(text):
    """A simple function to strip common markdown for plain text summaries."""
    text = re.sub(r'([*_`])', '', text)
    text = re.sub(r'---', '', text)
    text = re.sub(r'#+\s', '', text)
    text = re.sub(r'\[(.*?)\]\(.*?\)', r'\1', text)
    return text

def save_story_as_markdown(story_entry, art_path):
    """Creates an individual .md file for a story."""
    date_iso_string = story_entry['date']
    date_obj = datetime.datetime.fromisoformat(date_iso_string)
    # Sanitize filename
    safe_date_string = date_obj.isoformat().replace(":", "-").replace("+", "_")
    
    filename = f"{safe_date_string}.md"
    filepath = os.path.join(STORIES_DIR, filename)

    # Use only the filename for the art path in the markdown
    art_filename = os.path.basename(art_path) if art_path else ""
    cover_art_md = f"![Cover Art](../art/{art_filename})" if art_filename else ""

    content = f"""---
title: "{story_entry['title']}"
date: "{date_iso_string}"
theme: "{story_entry['theme']}"
format: "{story_entry['format']}"
---

{cover_art_md}

{story_entry['story']}

---

> ## Curator's Note
>
> {story_entry['curators_note']}
"""
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(content)

def update_rss_feed(history):
    """Generates a correctly formatted RSS feed, including cover art."""
    print("-> Building final RSS feed...")

    namespaces = {
        "atom": "http://www.w3.org/2005/Atom",
        "content": "http://purl.org/rss/1.0/modules/content/",
        "media": "http://search.yahoo.com/mrss/"
    }
    
    for prefix, uri in namespaces.items():
        ET.register_namespace(prefix, uri)
    
    rss = ET.Element("rss", version="2.0")
    channel = ET.SubElement(rss, "channel")

    base_url = "https://harrydekat.github.io/eidolon-project/"
    viewer_url = f"{base_url}viewer.html"
    
    ET.SubElement(channel, "title").text = "The Eidolon Project"
    ET.SubElement(channel, "link").text = viewer_url
    channel.append(ET.Element(ET.QName(namespaces["atom"], "link"), attrib={"href": f"{base_url}rss.xml", "rel": "self", "type": "application/rss+xml"}))
    ET.SubElement(channel, "description").text = "A daily, psychologically-rich story generated by AI."
    ET.SubElement(channel, "language").text = "en-us"
    ET.SubElement(channel, "lastBuildDate").text = datetime.datetime.now(datetime.timezone.utc).strftime("%a, %d %b %Y %H:%M:%S %z")

    # Styles
    container_style = "font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; color: #333333; padding: 10px 20px; max-width: 700px; margin: auto;"
    art_style = "max-width: 100%; height: auto; border-radius: 8px; margin-bottom: 25px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);"
    meta_style = "font-size: 14px; font-style: italic; color: #888888; margin-bottom: 25px;"
    hr_style = "border: 0; border-top: 1px solid #dddddd; margin: 40px 0;"
    note_container_style = "background-color: #f7f7f7; border-left: 4px solid #cccccc; padding: 15px 20px; margin-top: 30px; font-size: 15px;"
    note_title_style = "font-weight: bold; color: #1a1a1a; margin: 0 0 10px 0;"
    
    cdata_replacements = {}

    for entry in history:
        item = ET.SubElement(channel, "item")
        
        encoded_date = urllib.parse.quote(entry['date'])
        story_link = f"{viewer_url}?id={encoded_date}"
        
        ET.SubElement(item, "title").text = clean_invalid_xml_chars(entry['title'])
        ET.SubElement(item, "link").text = story_link
        pub_date = datetime.datetime.fromisoformat(entry['date']).strftime("%a, %d %b %Y %H:%M:%S %z")
        ET.SubElement(item, "pubDate").text = pub_date
        ET.SubElement(item, "guid", isPermaLink="true").text = story_link

        cleaned_story = clean_invalid_xml_chars(entry['story'])
        cleaned_note = clean_invalid_xml_chars(entry['curators_note'])
        pretty_theme = entry['theme'].replace('_', ' ').title()
        pretty_format = entry['format'].replace('_', ' ').title()

        plain_text_story = strip_markdown(cleaned_story)
        excerpt = (plain_text_story[:250] + '...') if len(plain_text_story) > 250 else plain_text_story
        ET.SubElement(item, "description").text = f"{excerpt}\n\n[Theme: {pretty_theme}]"

        story_html = markdown.markdown(cleaned_story.strip(), extensions=['nl2br'])
        note_html = markdown.markdown(cleaned_note.strip(), extensions=['nl2br'])

        # Cover Art Integration
        art_html = ""
        if entry.get("cover_art_path"):
            art_url = f'{base_url}output/{entry["cover_art_path"]}'
            art_html = f'<img src="{art_url}" alt="Cover art for {clean_invalid_xml_chars(entry["title"])}" style="{art_style}" />'
            # Add media:content for better RSS reader support
            media_content = ET.SubElement(item, ET.QName(namespaces["media"], "content"), {
                "url": art_url,
                "medium": "image",
                "type": "image/png"
            })
            ET.SubElement(media_content, ET.QName(namespaces["media"], "title")).text = clean_invalid_xml_chars(entry['title'])


        full_html_content = f"""
        <div style="{container_style}">
            {art_html}
            <p style="{meta_style}">Theme: {pretty_theme}<br/>Format: {pretty_format}</p>
            {story_html}
            <hr style="{hr_style}" />
            <blockquote style="{note_container_style}">
                <p style="{note_title_style}">Curator's Note</p>
                {note_html}
            </blockquote>
        </div>
        """
        
        placeholder = f"__EIDOLON_CONTENT_{entry['date']}__"
        cdata_replacements[placeholder] = f"<![CDATA[{full_html_content.strip()}]]>"
        ET.SubElement(item, ET.QName(namespaces["content"], "encoded")).text = placeholder

    xml_string = ET.tostring(ET.ElementTree(rss).getroot(), encoding='unicode')

    for placeholder, real_content in cdata_replacements.items():
        xml_string = xml_string.replace(placeholder, real_content)

    pretty_xml_str = minidom.parseString(xml_string).toprettyxml(indent="  ")

    with open(RSS_FILE, 'w', encoding='utf-8') as f:
        f.write(pretty_xml_str)